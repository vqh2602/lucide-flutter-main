import 'dart:convert';
import "dart:io";

import 'package:recase/recase.dart';

void main(List<String> args) {
  File fontsPreviewFile = File(args[0]);

  if (!fontsPreviewFile.existsSync()) {
    print('lucide preview file not found');
    exit(0);
  }

  String content = fontsPreviewFile.readAsStringSync();

  Map<String, dynamic> jsonMap = json.decode(content);
  Map<String, Map<String, String>> result = {};

  jsonMap.forEach((key, value) {
    if (value is Map<String, String>) {
      result[key] = Map<String, String>.from(value);
    }
  });

  List<Map<dynamic, dynamic>> resultList = jsonMap.entries
      .map((entry) => {'name': entry.key, ...entry.value})
      .toList();
  // stdout.write("info message1 ${resultList}");
  // final c = parse(content);
  // final list = c.getElementsByClassName('glyph');

  List<String> generatedOutput = [
    "library lucide_icons;\n",
    "import \"package:flutter/widgets.dart\";\n",
    "import \"src/icon_data.dart\";\n\n",
    "export \"src/lucide_icon_widget.dart\";\n\n"
        "// THIS FILE IS AUTOMATICALLY GENERATED!\n\n",
    "/// Lucide Icons\n",
    "class LucideIcons {\n",
    "/// Private constructor to prevent instantiation.\n",
    "/// This class is intended solely for organizing static icon definitions.\n",
    "/// Making the constructor private stops the IDE from suggesting object creation.\n",
    "const LucideIcons._();\n\n",
  ];
  List<String> listIconTest = [
    "\nimport 'package:flutter/material.dart';",
    "\nimport 'package:lucide_icons_flutter/lucide_icons.dart';",
    "\n/// Lucide Icons",
    "\nList<IconData> icons = ["
  ];
// {
//   "accessibility": {
//     "encodedCode": "\\e28c",
//     "prefix": "icon",
//     "className": "icon-accessibility",
//     "unicode": "&#57996;"
//   },
  // for (final icon in list) {
  //   final name = icon
  //       .getElementsByClassName('className')
  //       .first
  //       .attributes['value']!
  //       .replaceFirst('.icon-', '');
  //   stdout.write("info message");
  //   final val = icon
  //       .getElementsByClassName('unicode')
  //       .first
  //       .attributes['value']!
  //       .replaceFirst('&#x', '')
  //       .replaceFirst(';', '');
  for (Map data in resultList) {
    String iconName = data['name'];
    String svgContent = '';

    try {
      File svgFile = File('../icons/${iconName}.svg');
      if (svgFile.existsSync()) {
        svgContent = svgFile.readAsStringSync();

        // Đảm bảo SVG có kích thước nhỏ và đơn giản
        svgContent = svgContent
            .replaceAll(
                'stroke="currentColor"', 'stroke="#0066cc"') // Màu đỏ nổi bật
            // .replaceAll(
            //     'stroke-width="2"', 'stroke-width="3"') // Đường viền dày hơn
            .replaceAll('width="24"', 'width="48"') // Kích thước lớn hơn
            .replaceAll('height="24"', 'height="48"');

        // Thêm thuộc tính XML cần thiết
        if (!svgContent.contains('xmlns="http://www.w3.org/2000/svg"')) {
          svgContent = svgContent.replaceFirst(
              '<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
        }

        // Đảm bảo SVG có đủ các thuộc tính cần thiết
        svgContent = svgContent.replaceFirst('<svg', '<svg version="1.1"');

        // Mã hóa SVG thành base64 với định dạng chuẩn
        svgContent = base64Encode(utf8.encode(svgContent));
      }
    } catch (e) {
      print('Không thể đọc SVG cho $iconName: $e');
    }

    if (svgContent.isEmpty) {
      // Tạo một SVG đơn giản nếu không tìm thấy file
      String fallbackSvg =
          '<svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="#ff0000" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg>';
      svgContent = base64Encode(utf8.encode(fallbackSvg));
    }

    // Sử dụng URL data với định dạng đầy đủ
    generatedOutput.add("/// ${data['name']}\n" +
        "/// ![${data['name']}](data:image/svg+xml;base64,${svgContent})\n" +
        "static const IconData ${ReCase(data['name']).camelCase} = const LucideIconData(${parseUnicodeString(data['unicode'])});\n");
    listIconTest.add("\nLucideIcons.${ReCase(data['name']).camelCase},");
  }
  // print('$val $name');
  // }

  generatedOutput.add("}\n");
  listIconTest.add("];");
  //  stdout.write("info message2 ${generatedOutput}");

  File output = File('../lib/lucide_icons.dart');
  output.writeAsStringSync(generatedOutput.join());
  File outputTest = File('../lib/test_icons.dart');
  outputTest.writeAsStringSync(listIconTest.join());
}

int parseUnicodeString(String unicodeString) {
  // Remove the '&#' prefix and ';' suffix from the string
  String hexString = unicodeString.substring(2, unicodeString.length - 1);

  // Parse the hexadecimal string and convert it to an integer
  int unicodeInt = int.parse(hexString);

  return unicodeInt;
}

int parseUnicodeString2(String unicodeString) {
  // Remove the '\\' prefix from the string
  String hexString = unicodeString.substring(2);

  // Parse the hexadecimal string and convert it to an integer
  int unicodeInt = int.parse(hexString, radix: 16);

  return unicodeInt;
}
